# Go 与 C# 的对比，第二部分 —— 垃圾回收

> 早起写过一个这个系列的文章, [Part 1: Goroutines vs Async-Await](https://medium.com/@alexyakunin/go-vs-c-part-1-goroutines-vs-async-await-ac909c651c11), 中文版可以看[Go 与 C# 对比 第一篇：Goroutines 与 Async-Await](https://studygolang.com/articles/19399)

这篇文章是几个月前写的，内容也不是特别多，主要介绍了Go 的GC 不如.NET的几个点。相关的文章可以参阅下面这些链接[1](https://blog.plan99.net/modern-garbage-collection-911ef4f8bd8e),[2](https://making.pusher.com/golangs-real-time-gc-in-theory-and-practice/),[3](https://blog.cloudflare.com/go-dont-collect-my-garbage/),[4](http://mattwarren.org/2017/01/13/Analysing-Pause-times-in-the-.NET-GC/)

但是我依然忍不住想测试一下相关的数据，所以我找了一个Go方面的专家好友，帮助我完成一些基准测试。我们写了一个[GCBurn](https://github.com/alexyakunin/GCBurn),这是一个相对简单的垃圾收集和内存分配的基准测试，目前只支持C#和Go语言，但是你可以很轻松的把它移植到其他语言的GC上面。

废话不多说，开启我们的旅程吧。

## 垃圾回收期的概念

这部分内容非常长，如果你已经了解相关内容的话，请自动跳到下一节。

垃圾回收（GC，Garbage Collector）是运行时的一部分，负责回收已经“死掉”对象的内存，工作原理如下：
- 存活对象表示在堆内存中的，正在被其他人使用的对象（指向他的指针被一个CPU寄存器里面）, 或者在接下来的时间内，可能被使用的对象（可能有一个程序最终指向这个对象）。如果你把堆内存想象成一个对象彼此引用关系的图形，那就很容易理解，一个对象O存活的话，那么他直接引用的O1 ~ On 都活着。你可以通过指针访问O的话，同样也可以通过指针访问O1 ~ On，他们每一个都是存活对象。简单来说，如果一个Q对于一个存活的A对象可达，那么Q就是存活对象。
- 死亡对象就是堆内存中所有的非存活对象。之所以称他们已经死亡，是因为代码中没有任何方法可以再次访问到他们了。正因为无法访问，所以也无法使用了。
- 这里用一个现实场景的例子来举例，你从某一个城市的机场出发的话，你希望了解的是你能到达的所有城市。

这个定义也揭示了垃圾回收算法的基本工作内容：它必须实时检查哪些对象是可达的（存活的），并释放掉其他的内容。他的工作步骤如下：
- 暂停所有线程
- 标记所有的GC root（包括CPU寄存器引用内容，本地/方法调用栈，静态字段引用内容，所有正在使用的和马上要用的内容）为存活对象
- 将所有GC可到达的对象标记为存活对象，反之为死亡对象
- 让死亡对象的内存可以再次被利用。这里的实现方式有很多种，你可以将它标记为“允许未来分配”，或者通过移动所有存活对象来压缩栈空间，减少内存空隙。
- 最后回复所有线程。

上述的内容通常被叫做"[Mark and Sweep](https://www.geeksforgeeks.org/mark-and-sweep-garbage-collection-algorithm/)"的GC方式，它的实现比较直观，但却不是效果最好的一种。值得注意的是，他需要暂停一切内容来进行GC操作。所以大家也给这种垃圾回收期一个别名，叫做Stop-the-World 或者STW回收器。由此产生了相对应的 [几乎不暂停的垃圾回收期](https://www.google.com/search?q=pauseless+GC)（译者注：原单词为Pauseless，更贴近我们所说的并发垃圾回收期）

与STW回收期相比，并没有根本上的变化。他只是让回收过程跟代码同时执行。显然，这种方式很棘手。我们回到现实生活中的对比内容，试图将机场可达的城市匹配起来，假设：
- 假如你没有地图，但是你有一个车队。
- 在车辆行驶的过程中，新的城市和道路正在修建，而有一些道路正在被摧毁。

以上描述的场景让问题变得很复杂，特别是，你不能记录下你走过所有路的情况：你需要检查车队是否在运行（GC正在找寻存活对象），是否已经从最新创建出来的一个城市到达了下一个节点（GC已经标记了新城市为存活的对象）。如果上述内容成立，你还需要返回到上一个节点，通过那里在查找一次所有的存活对象。

翻译成人话就是，当GC执行的时候，任何指针的写入操作都需要进行一遍特殊的检查，这种方式同样会拖慢你的代码。

暂停与非暂停的GC回收期没有完全颠覆性的区别。只是影响了暂停的时长罢了。
- STW的暂停时间，取决于那些因素呢？比如说，他是固定的还是与存活对象的数量成正比？
- 如果是固定的，那实际是多久呢？如果对于你的业务场景，他的数量你可以忽略不计，那就可以当成是没有暂停时间的GC了。
- 如果不是固定的，我们是否可以让他不要超过我们预想的一个最大能承受的值呢？

不同的GC实现，对于不同的因素进行了一些优化。
- GC拖慢了整体的程序（程序吞吐量影响）—— GC暂停时间占整体运行时间的百分比
- STW暂停时间的分布情况 —— 显然是越短越好，最好与存活对象数量无关
- GC使用的内存比例，包括特殊实现占用的部分。